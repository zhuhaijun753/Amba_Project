# 1 搭建山海关的开发环境
## 1.1 安装交叉编译工具链
交叉编译工具链在nas服务器上，路径为：</br>
/nas/users/platform/AMBA_4_CV25_linux_shanhaiguan/tools/Ambarella_Toolchain_Linaro_2020.09.tar.xz。</br>
解压此文件，然后运行安装脚本：</br>
tar pxvf Ambarella_Toolchain_Linaro_2020.09.tar.xz</br>
cd Ambarella_Toolchain_Linaro_2020.09</br>
sudo ./ubuntuToolChain-linux5.4-202008</br>
这样交叉编译工具链就安装完成。</br>
## 1.2 clone山海关工程的仓库
仓库地址为http://192.168.1.124/liyunlong/shg_amba_cv25_sdk_3_0_2</br>
## 1.3 source build.sh
进入shg_amba_cv25_sdk_3_0_2/cv25_linux_sdk_3.0.2/ambarella/boards/cv25_hazelnut目录，运行source build.sh</br>
如果出现Check env error, please install mkfs.jffs2genext2fsmkcramfs错误。需要安装这些库：</br>
mkfs.jffs2：sudo apt-get install mtd-utils</br>
genext2fs：sudo apt install genext2fs</br>
mkcramfs：sudo apt-get install mkcramfs</br>
如果提示缺少crypto，那么就需要安装crypto python库：</br>
sudo apt-get install python3-crypto</br>
再次source build.sh，直到没有错误出现，如下所示：</br>
============================================================
TOOLCHAIN    PATH: /usr/local/linaro-aarch64-2020.09-gcc10.2-linux5.4
TOOLCHAIN    NANE: aarch64-linux-gnu-gcc
TOOLCHAIN VERSION: 10.2.1
============================================================
#
# configuration written to .config
#
Build Linux-5.4 with cv25_emmc_kernel_config ...
## 1.4 编译山海关项目工程
进入shg_amba_cv25_sdk_3_0_2/cv25_linux_sdk_3.0.2/ambarella/boards/cv25_hazelnut/目录中，运行make命令：</br>
cd shg_amba_cv25_sdk_3_0_2/cv25_linux_sdk_3.0.2/ambarella/boards/cv25_hazelnuts</br>
make -j8</br>
编译完成后，终端显示信息如下所示：
```
...
...
/home/public/shg_amba_cv25_sdk_3_0_2/cv25_linux_sdk_3.0.2/ambarella/out/cv25_hazelnut/rootfs/ext4: clean, 3281/3584 files, 427637/457988 blocks
Build Amboot ... 
Build AmBST ...
Build Done
```
这样就在shg_amba_cv25_sdk_3_0_2/cv25_linux_sdk_3.0.2/ambarella/下生成了out文件夹，里面包含编译生成的镜像和可执行程序，下面烧写步骤中的elf文件就在这个文件夹里。
# 2 针对新拿到的山海关板子烧写
## 2.1 安装烧写工具
烧写工具的路径为：/nas/users/platform/AMBA_4_CV25_linux_shanhaiguan/tools/Ambarella_AmbaUSB_v4.2.6.zip
烧写工具可以运行在不同的OS上——Ubuntu 18.04或者Windows。安装烧写工具。
## 2.2 用USB线连接山海关板子和PC机，用串口线连接山海关板子的UART串口


## 2.3 打开烧写工具，界面如下：

由于我们的SOC为cv25，所以右面选择CV25。
## 2.4 短接山海关板子上的预留端点（POC[10]）可以进入USB烧写模式。我们这里使用镊子进行短接，如下图所示。基本步骤：POC[10]短接-->板子上电-->插上USB线-->点击烧写按钮。

## 2.5 进行烧写
点击蓝色按钮进行烧写。

## 2.6 烧写完成（图片两个红框都满足，代表烧写完成）：


# 3 建立NFS
可以参看《Ambarella_CV2x_UG_Flexible_Linux_SDK3.0_Code_Building_and_Debug_Environment.pdf》文档的“6.5Network Sharing: NFS”部分。
## 3.1 通过串口设置IP地址，比如设置为192.168.1.178
vi /etc/network/interfaces
添加如下内容：
```
auto eth0
iface eth0 inet static
address 192.168.1.178   # IP地址， 要根据自己网段下IP的使用设置，不能和别的IP相冲突
netmask 255.255.255.0
gateway 192.168.1.1   
```
保存后，重新启动板子。然后ping一下其他IP地址，确认网络通信正常。
## 3.2 在PC机上建立nfs文件夹，并编辑PC机上的/etc/exports文件
确保PC机上已经启动了nfs服务，可以用service nfs-server status命令查看。然后建立/home/public/shanhaiguan_nfs文件夹，</br>
然后添加nfs信息，即在/etc/exports文件最后添加下面一行：
```
/home/public/shanhaiguan_nfs *(rw,nohide,insecure,no_subtree_check,async,no_root_squash)
```
然后运行exportfs -a命令，使修改后的/etc/exports立即生效。
## 3.3 在板子上进行mount
在板子上建立nfs对应的（对应主机的/home/public/shanhaiguan_nfs）文件夹：/nfs_zhuhaijun。然后运行如下mount命令：
mount -t nfs -o nolock,vers=3 192.168.1.110:/home/public/shanhaiguan_nfs /nfs_                                                                                          
zhuhaijun
这样就完成了nfs的挂载，可以看到PC机上的文件可以在板子上显示。
# 4 安霸SDK的特点
## 4.1 SDK软件架构

## 4.2 SDK目录结构
SDK的顶层目录为shg_amba_cv25_sdk_3_0_2/cv25_linux_sdk_3.0.2/ambarella，现在对目录里包含的内容进行简要说明：</br>
AMBoot/ Boot loader, board support toolkit, and file system information about the partitions.</br>
app/ Demo applications.</br>
boards/ The compile configuration files, DDR configuration, and boot strap.</br>
build/ The make file rules and AmbaConfig rules.</br>
document/ The Doxygen content and configuration rules.</br>
include/ Header files.</br>
kernel/ Linux kernel, DSP firmware, IAV / DSP / sensor and peripheral devices drivers.</br>
external Codes of external Wi-Fi modules</br>
linux-5.4 Codes of Linux kernel and patches.</br>
private Codes and binaries of Ambarella propriety drivers or modules.</br>
license/ The license files of each component.</br>
out/ The build target and intermediate objects.</br>
packages/ The libraries that assist in video processing, streaming, or transferring.</br>
data_transfer Codes of data storage over NFS and data transferring over USB/TCP.</br>
img_algo (Source codes are not released) Image algorithm library.The prebuilt binary is in ambarella/prebuild/imgproc.</br>
utils Utility library codes</br>
nnctrl Initial cavalry binary which is generated by cavalry_gen</br>
vproc Some pre-defined DAGs used to convert the date format</br>
prebuild/ The prebuilt binaries including Ambarella libraries and third-party libraries.</br>
ambarella/library Binary format of various Ambarella proprietary library</br>
imgproc Binary format library file and image tuning parameter files</br>
third-party Binary format library files from the third party</br>
rootfs/ The root file system.</br>
unit_test/ Unit test tools.</br>
## 4.3 Linux驱动和应用库
IAV driver (main interface for the application to call CODEC functions)</br>
Cavalry driver (main interface for the application to call VP functions)</br>
DSP, VIN, VOUT drivers (GPLv2 Linux modules)</br>
Sensor driver (Proprietary Linux modules)</br>
Image processing driver (Proprietary Linux modules)</br>
Image processing (AE / AWB) library ( libimg_algo_v5.a / libimg_dsp_v5_hf.a )</br>
Image processing flow library ( libimg_aaa_flow_v5.so )</br>
Multi-channel Lua parser library ( libmcl.so )</br>
Neural network flow control library ( libnnctrl.so )</br>
Neural network data processing library ( libvproc.so )</br>
Neural network memory management library ( libcavalry_mem.so )</br>
CNNGen Pre-Processing library ( libcgpp.so )</br>
Easy AI library ( libeazyai.so )</br>
Smart VOUT framebuffer library ( libsmartfb.so )</br>
Electronic image stabilization library ( libeis.so )</br>
Lens distortion correction library ( libdewarp.so )</br>
Multi-region warp library ( libdewarp.so )</br>
Smart rate controll library ( libsmartrc_3_0.so )</br>
Text insertion library ( libtextinsert.a )</br>
Arbitrary Blur library ( libblur.so )</br>
Audio codec library (ALSA, libasound.a )</br>
## 4.4 demo和测试应用程序
Unit test to capture / parse DSP log ( dsplog_cap )</br>
Unit test to test encode and streaming ( test_encode, test_stream )</br>
Unit test to exercise Digital Pan / Tilt / Zoom ( test_dptz )</br>
Unit test to exercise privacy mask functionality ( test_privacymask )</br>
Unit test to exercise overlay insert functionality ( test_overlay, test_textinsert )</br>
Unit test to exercise blur insert functionality ( test_blur )</br>
Unit test to capture RAW / YUV / ME1 / ME0 data ( test_yuvcap )</br>
Unit test to enable MB / CTB level smart encoding ( test_frame_sync, test_sync_roi, test_sync_stream, test_qproi )</br>
Unit test to run 3A process ( test_tuning, test_aaa_service )</br>
Unit test to encode / decode AAC audio ( test_aacdec, test_aacenc )</br>
Unit test to exercise video decode functionality ( test_decode )</br>
Unit test to exercise encode from memory (EFM) functionality ( test_efm )</br>
Unit test to exercise Lens Distortion Correction (LDC) functionality ( test_ldc )</br>
Unit test to run multi-channel functionality ( test_multi_chan )</br>
Unit test to exercise VIN signal suspend / recovery functionality ( test_vin_cap )</br>
Unit test to exercise pyramid manual feed functionality ( test_pyramid_mf )</br>
Unit test to exercise canvas manual feed functionality ( test_manual_feed )</br>
Unit test to exercise stream fps suggestion functionality ( test_fps_suggest )</br>
Unit test to exercise NetLink functionality ( test_netlink )</br>
Unit test to exercise IDSP/encoder synchronization functionality ( test_idsp_enc_sync )</br>
Unit test to exercise Electronic Image Stabilization (EIS) functionality ( test_eis_warp )</br>
Unit test to exercise fisheye dewarp functionality ( test_dewarp )</br>
Unit test to run Smart Rate Control (SRC) ( test_smartrc_pa )</br>
Unit test to exercise image scale functionality ( test_img_scale )</br>
Unit test to exercise customized SEI functionality ( test_custom_sei )</br>
Unit test to exercise stream statistics functionality ( test_statistics )</br>
Unit test to exercise HEVC scaling list functionality ( test_hevc_scalelist )</br>
Unit test to exercise IAV data poll functionality ( test_poll )</br>
Unit test to exercise custimized VOUT functionality ( test_custom_vout )</br>
Unit test to load CVflow firmware ( cavalry_load )</br>
Unit test to capture / parse CVflow log ( cavalry_log )</br>
Unit test to exercise NN flow control functionality ( test_nnctrl, test_nnctrl_live )</br>
Unit test to exercise FMA functionality ( test_cavalry_fma, test_cavalry_fma_live )</br>
Unit test to exercise NN memory management functionality ( test_cavalry_mem )</br>
Application to run RTSP streaming ( rtsp_server )</br>
Application to load DSP microcode ( load_ucode )</br>
Application to run classification ( Yolo-v2, Yolo-v3 )</br>
Application to run face detection ( MTCNN )</br>
